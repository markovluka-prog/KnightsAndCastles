<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Рыцари и Замки</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --bg: #1a1410;
  --panel: #221a14;
  --panel-2: #2b2018;
  --text: #d9ccb5;
  --muted: #998b76;
  --grid: #3c3228;
  --p1: #59a3ff;
  --p2: #e35757;
  --ok: #67cf6f;
  --warn: #f2c14f;
}

body {
  min-height: 100vh;
  background: var(--bg);
  color: var(--text);
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: "Segoe UI", Tahoma, sans-serif;
}

#app {
  width: 780px;
  height: 960px;
  display: flex;
  border: 2px solid #34281f;
  box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
}

#gameCanvas {
  width: 480px;
  height: 960px;
  display: block;
  background: #0e0e0e;
  image-rendering: pixelated;
  cursor: pointer;
}

#sidebar {
  width: 300px;
  height: 960px;
  background: linear-gradient(180deg, var(--panel), #17110d);
  border-left: 2px solid var(--grid);
  overflow-y: auto;
  padding: 14px;
}

#sidebar::-webkit-scrollbar {
  width: 8px;
}

#sidebar::-webkit-scrollbar-thumb {
  background: #3a2f25;
  border-radius: 6px;
}

.menu-wrap {
  min-height: 932px;
  display: flex;
  flex-direction: column;
}

.menu-title {
  font-size: 28px;
  letter-spacing: 0.6px;
  margin-bottom: 10px;
  color: #ffe3b2;
}

.card {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid #3f3228;
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 10px;
}

.rules {
  line-height: 1.4;
  color: var(--muted);
  font-size: 14px;
}

.menu-buttons {
  margin-top: auto;
  display: grid;
  gap: 10px;
}

.btn {
  width: 100%;
  border: 2px solid;
  border-radius: 8px;
  padding: 10px 12px;
  color: #f4ead8;
  background: #302519;
  cursor: pointer;
  font-size: 15px;
  text-align: left;
  transition: filter 0.12s ease;
}

.btn:hover {
  filter: brightness(1.15);
}

.btn:disabled {
  filter: grayscale(0.5) brightness(0.7);
  cursor: not-allowed;
}

.btn.primary {
  border-color: #f2cf63;
  background: #4a3518;
}

.btn.secondary {
  border-color: #93c3ff;
  background: #263141;
}

.btn.skip {
  border-color: #99917f;
  background: #373224;
}

.btn.danger {
  border-color: #d26565;
  background: #4b1f1f;
}

.btn.restart {
  border-color: #75d67a;
  background: #244a25;
}

.section {
  margin-bottom: 10px;
}

.section h3 {
  margin-bottom: 6px;
  font-size: 15px;
  color: #ffe8b0;
}

.line {
  font-size: 13px;
  line-height: 1.35;
  color: var(--muted);
}

.sep {
  border: 0;
  border-top: 1px solid #3f3228;
  margin: 8px 0;
}

.player-label {
  font-size: 22px;
  font-weight: 700;
  margin-bottom: 6px;
}

.player-p1 {
  color: var(--p1);
}

.player-p2 {
  color: var(--p2);
}

.message {
  font-size: 13px;
  color: #cebfa9;
  margin-bottom: 4px;
}

.score {
  font-size: 13px;
  color: #a9977f;
}

.preview {
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}

.preview canvas {
  width: 144px;
  height: 144px;
  border: 1px solid #4a3b2c;
  border-radius: 8px;
  background: #241c15;
}

.preview-title {
  font-size: 15px;
  color: #f0e0c8;
}

.kv {
  font-size: 13px;
  color: #bcae96;
}

.tag {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 12px;
  border: 1px solid #5f4d3b;
  font-size: 11px;
  margin-left: 4px;
}

.inventory-row {
  font-size: 12px;
  color: #bcae96;
  margin-bottom: 2px;
}

.inventory-row.empty {
  opacity: 0.45;
}

.inventory-row.has {
  opacity: 1;
}

.recipe {
  font-size: 11px;
  color: #9f9077;
  margin-top: 3px;
}

.hint {
  font-size: 12px;
  color: #e8bf6a;
}

.badge {
  font-size: 11px;
  color: #f2cf63;
}

.badge.p1 {
  color: var(--p1);
}

.badge.p2 {
  color: var(--p2);
}

.loading {
  color: #e5ca7c;
  font-size: 14px;
}
</style>
</head>
<body>
<div id="app">
  <canvas id="gameCanvas" width="480" height="960"></canvas>
  <aside id="sidebar"></aside>
</div>

<script>
(function () {
  "use strict";

  const CELL_SIZE = 48;
  const COLS = 10;
  const ROWS = 20;
  const WIDTH = COLS * CELL_SIZE;
  const HEIGHT = ROWS * CELL_SIZE;

  const COLORS = {
    bg: "#1a1410",
    grid: "#3c3228",
    groundA: "#557832",
    groundB: "#4e7030",
    move: "rgba(65, 190, 70, 0.35)",
    attack: "rgba(210, 65, 65, 0.35)",
    selected: "#e8c35b",
    p1: "#59a3ff",
    p2: "#e35757"
  };

  const ARTIFACTS = [
    "Трава серебряных",
    "Палочка заклинаний",
    "Трава С.",
    "Посох огня",
    "Волшебная палочка",
    "Солнечные часы",
    "Вода серебряных трав"
  ];

  const ARTIFACT_COLORS = {
    "Трава серебряных": "#b8e3ae",
    "Палочка заклинаний": "#cfb4ff",
    "Трава С.": "#8fdd7f",
    "Посох огня": "#ff8d62",
    "Волшебная палочка": "#dfb2ff",
    "Солнечные часы": "#ffe281",
    "Вода серебряных трав": "#85c9ff"
  };

  const UNIT_TYPES = {
    knight: {
      name: "Рыцарь",
      hp: 3,
      damage: 5,
      armor: 4,
      moves: 2,
      frame: 192,
      letter: "K"
    },
    cavalry: {
      name: "Конный",
      hp: 5,
      damage: 6,
      armor: 3,
      moves: 3,
      frame: 320,
      letter: "L"
    },
    archer: {
      name: "Лучник",
      hp: 3,
      damage: 2,
      armor: 1,
      moves: 3,
      frame: 192,
      letter: "A"
    }
  };

  const SPELLS = [
    {
      name: "Дождь защиты",
      recipe: {
        "Трава серебряных": 2,
        "Палочка заклинаний": 1,
        "Трава С.": 1
      },
      desc: "+2 HP всем своим"
    },
    {
      name: "Сталь свободы",
      recipe: {
        "Посох огня": 1,
        "Трава серебряных": 1,
        "Волшебная палочка": 1
      },
      desc: "+2 Armor всем своим"
    },
    {
      name: "Небо огня",
      recipe: {
        "Трава С.": 3,
        "Палочка заклинаний": 1,
        "Солнечные часы": 1
      },
      desc: "Щит на 1 ход противника"
    }
  ];

  const WEAPONS = [
    {
      name: "Солнечный меч",
      recipe: {
        "Посох огня": 1,
        "Палочка заклинаний": 1,
        "Солнечные часы": 1
      },
      desc: "+3 урона выбранному юниту",
      amount: 3,
      archerOnly: false
    },
    {
      name: "Синий лук",
      recipe: {
        "Вода серебряных трав": 1,
        "Трава С.": 2,
        "Посох огня": 1,
        "Палочка заклинаний": 1
      },
      desc: "+2 урона лучнику",
      amount: 2,
      archerOnly: true
    }
  ];

  const TOWERS = [
    { row: 5, col: 3 },
    { row: 5, col: 6 },
    { row: 14, col: 3 },
    { row: 14, col: 6 }
  ];

  const RUINS = {
    top: 9,
    left: 4,
    width: 2,
    height: 2
  };

  const START_POSITIONS_P1 = [
    { type: "cavalry", row: 3, col: 4 },
    { type: "cavalry", row: 3, col: 5 },
    { type: "knight", row: 1, col: 3 },
    { type: "knight", row: 1, col: 6 },
    { type: "knight", row: 2, col: 3 },
    { type: "knight", row: 2, col: 6 },
    { type: "knight", row: 0, col: 3 },
    { type: "archer", row: 0, col: 4 },
    { type: "archer", row: 0, col: 5 },
    { type: "knight", row: 0, col: 6 }
  ];

  const KEY_SPACE = "Space";

  function toKey(row, col) {
    return row + "," + col;
  }

  function otherPlayer(player) {
    return player === 1 ? 2 : 1;
  }

  function cloneRecipeText(recipe) {
    return Object.keys(recipe)
      .map((name) => recipe[name] + "x " + name)
      .join(", ");
  }

  function randomChoice(list) {
    const index = Math.floor(Math.random() * list.length);
    return list[index];
  }

  function insideBoard(row, col) {
    return row >= 0 && row < ROWS && col >= 0 && col < COLS;
  }

  function manhattan(r1, c1, r2, c2) {
    return Math.abs(r1 - r2) + Math.abs(c1 - c2);
  }

  class AssetStore {
    constructor() {
      this.items = {};
      this.pending = 0;
      this.resolved = 0;
      this.finished = false;
      this.onFinish = [];
    }

    add(key, src) {
      this.items[key] = {
        key,
        src,
        image: null,
        loaded: false,
        failed: false
      };
    }

    loadAll() {
      const keys = Object.keys(this.items);
      this.pending = keys.length;
      if (this.pending === 0) {
        this.finished = true;
        this.flushCallbacks();
        return;
      }
      keys.forEach((key) => {
        const item = this.items[key];
        const img = new Image();
        img.onload = () => {
          item.image = img;
          item.loaded = true;
          this.bump();
        };
        img.onerror = () => {
          item.failed = true;
          this.bump();
        };
        img.src = item.src;
      });
    }

    bump() {
      this.resolved += 1;
      if (this.resolved >= this.pending) {
        this.finished = true;
        this.flushCallbacks();
      }
    }

    flushCallbacks() {
      while (this.onFinish.length) {
        const cb = this.onFinish.shift();
        cb();
      }
    }

    whenFinished(cb) {
      if (this.finished) {
        cb();
      } else {
        this.onFinish.push(cb);
      }
    }

    get(key) {
      const item = this.items[key];
      if (!item || !item.loaded || !item.image) {
        return null;
      }
      return item.image;
    }

    stats() {
      return {
        pending: this.pending,
        resolved: this.resolved
      };
    }
  }

  class Unit {
    constructor(id, player, type, row, col) {
      const t = UNIT_TYPES[type];
      this.id = id;
      this.player = player;
      this.type = type;
      this.name = t.name;
      this.row = row;
      this.col = col;

      this.maxHp = t.hp;
      this.hp = t.hp;
      this.armor = t.armor;
      this.maxArmor = t.armor;
      this.damage = t.damage;
      this.maxMoves = t.moves;
      this.movesLeft = t.moves;

      this.done = false;
      this.activated = false;
    }

    alive() {
      return this.hp > 0;
    }

    resetTurn() {
      this.movesLeft = this.maxMoves;
      this.done = false;
      this.activated = false;
    }
  }

  class Board {
    constructor() {
      this.units = [];
      this.nextId = 1;
      this.initUnits();
    }

    initUnits() {
      this.units = [];
      this.nextId = 1;
      START_POSITIONS_P1.forEach((p) => {
        this.units.push(new Unit(this.nextId++, 1, p.type, p.row, p.col));
      });
      START_POSITIONS_P1.forEach((p) => {
        this.units.push(new Unit(this.nextId++, 2, p.type, 19 - p.row, p.col));
      });
    }

    unitAt(row, col) {
      for (let i = 0; i < this.units.length; i += 1) {
        const u = this.units[i];
        if (u.alive() && u.row === row && u.col === col) {
          return u;
        }
      }
      return null;
    }

    isFree(row, col) {
      return insideBoard(row, col) && !this.unitAt(row, col);
    }

    removeDead() {
      this.units = this.units.filter((u) => u.alive());
    }

    unitsOf(player) {
      return this.units.filter((u) => u.player === player && u.alive());
    }

    inRuins(row, col) {
      return (
        row >= RUINS.top &&
        row < RUINS.top + RUINS.height &&
        col >= RUINS.left &&
        col < RUINS.left + RUINS.width
      );
    }

    isTower(row, col) {
      return TOWERS.some((t) => t.row === row && t.col === col);
    }
  }

  class AIPlayer {
    constructor(game, player) {
      this.game = game;
      this.player = player;
      this.frameWait = 18;
      this.frameCounter = 0;
    }

    reset() {
      this.frameCounter = 0;
    }

    update() {
      if (!this.game.isGameActive()) {
        return;
      }
      if (this.game.mode !== "ai") {
        return;
      }
      if (this.game.currentPlayer !== this.player) {
        return;
      }
      if (this.game.winner !== null) {
        return;
      }
      this.frameCounter += 1;
      if (this.frameCounter < this.frameWait) {
        return;
      }
      this.frameCounter = 0;
      this.takeStep();
    }

    takeStep() {
      const game = this.game;
      if (game.currentPlayer !== this.player || game.winner !== null) {
        return;
      }

      if (game.selectedUnit && game.selectedUnit.player === this.player) {
        const action = this.bestActionForUnit(game.selectedUnit);
        this.executeAction(action);
        return;
      }

      const candidates = game
        .ownUnits(this.player)
        .filter((u) => !u.done)
        .filter((u) => game.canUnitAct(u));

      if (!candidates.length) {
        game.forceEndTurn();
        return;
      }

      let best = null;
      candidates.forEach((u) => {
        const action = this.bestActionForUnit(u);
        if (!action) {
          return;
        }
        if (!best || action.score > best.score) {
          best = {
            unit: u,
            action
          };
        }
      });

      if (!best) {
        game.forceEndTurn();
        return;
      }

      game.selectUnit(best.unit.row, best.unit.col, true);
      if (!game.selectedUnit || game.selectedUnit.id !== best.unit.id) {
        return;
      }
      const refined = this.bestActionForUnit(game.selectedUnit) || { type: "skip", score: -999 };
      this.executeAction(refined);
    }

    executeAction(action) {
      const game = this.game;
      if (!action) {
        game.skipSelected(true);
        return;
      }
      if (action.type === "attack") {
        game.performAttack(action.row, action.col, true);
        return;
      }
      if (action.type === "move") {
        game.performMove(action.row, action.col, true);
        return;
      }
      if (action.type === "draw") {
        game.drawArtifact(true);
        return;
      }
      if (action.type === "spell") {
        game.castSpell(action.index, true);
        return;
      }
      game.skipSelected(true);
    }

    bestActionForUnit(unit) {
      const game = this.game;
      if (!unit || unit.done || unit.movesLeft <= 0) {
        return { type: "skip", score: -300 };
      }

      const actions = [];
      const attackActions = game.attackActionsFor(unit);
      attackActions.forEach((a) => {
        const target = game.board.unitAt(a.targetRow, a.targetCol);
        if (!target || target.player === unit.player) {
          return;
        }
        const damage = game.computeDamage(unit, target);
        let score = 100 * damage;
        if (damage >= target.hp) {
          score += 10000;
        }
        if (unit.type === "cavalry") {
          score += 180;
        }
        if (unit.type === "archer") {
          score += 120;
        }
        if (unit.type === "knight") {
          score += 70;
        }
        actions.push({
          type: "attack",
          row: a.row,
          col: a.col,
          score
        });
      });

      if (game.board.inRuins(unit.row, unit.col) && unit.movesLeft >= 1) {
        actions.push({
          type: "draw",
          score: 200 + (unit.type === "knight" ? 15 : 0)
        });
      }

      if (game.board.isTower(unit.row, unit.col) && unit.movesLeft >= 1) {
        SPELLS.forEach((spell, index) => {
          if (!game.canAfford(game.inventory[this.player], spell.recipe)) {
            return;
          }
          let score = 500;
          if (index === 0) {
            const wounded = game
              .ownUnits(this.player)
              .reduce((sum, ally) => sum + Math.max(0, ally.maxHp - ally.hp), 0);
            score += wounded * 25;
          }
          if (index === 1) {
            score += 40 * game.ownUnits(this.player).length;
          }
          if (index === 2) {
            score += 150;
          }
          actions.push({
            type: "spell",
            index,
            score
          });
        });
      }

      const moveActions = game.moveActionsFor(unit);
      const nearestEnemyBefore = this.nearestEnemyDistance(unit.row, unit.col);
      const nearestTowerBefore = this.nearestTowerDistance(unit.row, unit.col);

      moveActions.forEach((m) => {
        const nearestEnemyAfter = this.nearestEnemyDistance(m.row, m.col);
        const nearestTowerAfter = this.nearestTowerDistance(m.row, m.col);

        let score = 0;
        const enemyDelta = nearestEnemyBefore - nearestEnemyAfter;
        if (enemyDelta > 0) {
          score += 20 * enemyDelta;
        }

        if (game.board.inRuins(m.row, m.col)) {
          score += 50;
        }

        const towerDelta = nearestTowerBefore - nearestTowerAfter;
        if (towerDelta > 0) {
          score += 5 * towerDelta;
        }

        if (unit.type === "cavalry") {
          score += 15 * enemyDelta;
        }

        if (unit.type === "archer") {
          if (nearestEnemyAfter <= 1) {
            score -= 120;
          } else {
            score += 20;
          }
        }

        if (unit.type === "knight" && game.turnNumber <= 3) {
          const idealRow = this.player === 2 ? 14 : 5;
          const beforeLine = Math.abs(unit.row - idealRow);
          const afterLine = Math.abs(m.row - idealRow);
          if (afterLine < beforeLine) {
            score += 60;
          }
        }

        actions.push({
          type: "move",
          row: m.row,
          col: m.col,
          score
        });
      });

      if (!actions.length) {
        return { type: "skip", score: -200 };
      }

      actions.sort((a, b) => b.score - a.score);
      return actions[0];
    }

    nearestEnemyDistance(row, col) {
      const enemies = this.game.ownUnits(otherPlayer(this.player));
      if (!enemies.length) {
        return 0;
      }
      let best = Infinity;
      enemies.forEach((e) => {
        best = Math.min(best, manhattan(row, col, e.row, e.col));
      });
      return best;
    }

    nearestTowerDistance(row, col) {
      let best = Infinity;
      TOWERS.forEach((t) => {
        best = Math.min(best, manhattan(row, col, t.row, t.col));
      });
      return best;
    }
  }

  class KnightsAndCastlesGame {
    constructor(canvas, sidebar, assets) {
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d");
      this.sidebar = sidebar;
      this.assets = assets;

      this.screen = "loading";
      this.mode = null;
      this.board = new Board();
      this.currentPlayer = 1;
      this.maxActivatedPerTurn = 3;
      this.activatedCount = 0;
      this.selectedUnit = null;
      this.previewUnitId = null;
      this.winner = null;
      this.turnNumber = 1;
      this.message = "";
      this.lastEvent = "";
      this.shieldTurns = { 1: 0, 2: 0 };

      this.inventory = {
        1: this.newInventory(),
        2: this.newInventory()
      };

      this.moveMap = new Map();
      this.attackMap = new Map();

      this.ai = new AIPlayer(this, 2);

      this.bindEvents();
      this.renderSidebar();
      this.loop();
    }

    bindEvents() {
      this.canvas.addEventListener("click", (event) => {
        const rect = this.canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) * (this.canvas.width / rect.width);
        const y = (event.clientY - rect.top) * (this.canvas.height / rect.height);
        this.handleCanvasClick(Math.floor(x), Math.floor(y));
      });

      this.canvas.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        this.skipSelected(false);
      });

      document.addEventListener("keydown", (event) => {
        if (event.code === KEY_SPACE) {
          event.preventDefault();
          this.skipSelected(false);
        }
      });

      this.sidebar.addEventListener("click", (event) => {
        const target = event.target.closest("button[data-action]");
        if (!target) {
          return;
        }
        const action = target.dataset.action;
        if (action === "start-pvp") {
          this.startMatch("pvp");
          return;
        }
        if (action === "start-ai") {
          this.startMatch("ai");
          return;
        }
        if (action === "skip") {
          this.skipSelected(false);
          return;
        }
        if (action === "surrender") {
          this.surrender();
          return;
        }
        if (action === "back-menu") {
          this.backToMenu();
          return;
        }
        if (action === "restart") {
          this.startMatch(this.mode || "pvp");
          return;
        }
        if (action === "draw-artifact") {
          this.drawArtifact(false);
          return;
        }
        if (action === "clear-preview") {
          this.previewUnitId = null;
          this.renderSidebar();
          return;
        }
        if (action === "cast-spell") {
          const idx = Number(target.dataset.idx);
          this.castSpell(idx, false);
          return;
        }
        if (action === "craft") {
          const idx = Number(target.dataset.idx);
          this.craftWeapon(idx);
        }
      });
    }

    newInventory() {
      const inv = {};
      ARTIFACTS.forEach((a) => {
        inv[a] = 0;
      });
      return inv;
    }

    onAssetsReady() {
      this.screen = "menu";
      this.message = "Выберите режим игры";
      this.renderSidebar();
    }

    backToMenu() {
      this.screen = "menu";
      this.mode = null;
      this.selectedUnit = null;
      this.previewUnitId = null;
      this.winner = null;
      this.lastEvent = "";
      this.clearHighlights();
      this.message = "Выберите режим игры";
      this.ai.reset();
      this.renderSidebar();
    }

    isGameActive() {
      return this.screen === "game";
    }

    startMatch(mode) {
      this.screen = "game";
      this.mode = mode;
      this.board = new Board();
      this.currentPlayer = 1;
      this.activatedCount = 0;
      this.selectedUnit = null;
      this.previewUnitId = null;
      this.winner = null;
      this.turnNumber = 1;
      this.message = "";
      this.lastEvent = "";
      this.shieldTurns = { 1: 0, 2: 0 };
      this.inventory = {
        1: this.newInventory(),
        2: this.newInventory()
      };
      this.clearHighlights();
      this.startTurn();
      this.ai.reset();
    }

    startTurn() {
      this.activatedCount = 0;
      this.selectedUnit = null;
      this.clearHighlights();
      this.ownUnits(this.currentPlayer).forEach((u) => {
        u.resetTurn();
      });

      const maxCanActivate = Math.min(this.maxActivatedPerTurn, this.ownUnits(this.currentPlayer).length);
      this.message = "Ход игрока " + this.currentPlayer + ". Активируйте до " + maxCanActivate + " юнитов.";
      this.renderSidebar();
    }

    ownUnits(player) {
      return this.board.unitsOf(player);
    }

    canUnitAct(unit) {
      if (!unit || !unit.alive() || unit.done) {
        return false;
      }
      if (unit.activated) {
        return true;
      }
      return this.activatedCount < this.maxActivatedPerTurn;
    }

    handleCanvasClick(px, py) {
      if (this.screen !== "game") {
        return;
      }

      const col = Math.floor(px / CELL_SIZE);
      const row = Math.floor(py / CELL_SIZE);
      if (!insideBoard(row, col)) {
        return;
      }

      const clickedUnit = this.board.unitAt(row, col);
      if (clickedUnit) {
        if (this.previewUnitId === clickedUnit.id) {
          this.previewUnitId = null;
        } else {
          this.previewUnitId = clickedUnit.id;
        }
      }

      if (this.winner !== null) {
        this.renderSidebar();
        return;
      }

      if (this.mode === "ai" && this.currentPlayer === 2) {
        this.renderSidebar();
        return;
      }

      if (this.selectedUnit) {
        const atk = this.attackMap.get(toKey(row, col));
        if (atk) {
          this.performAttack(row, col, false);
          return;
        }

        const mv = this.moveMap.get(toKey(row, col));
        if (mv) {
          this.performMove(row, col, false);
          return;
        }

        if (
          clickedUnit &&
          clickedUnit.player === this.currentPlayer &&
          !clickedUnit.done &&
          clickedUnit.id !== this.selectedUnit.id &&
          this.selectedUnit.movesLeft === this.selectedUnit.maxMoves
        ) {
          this.selectedUnit.activated = false;
          this.activatedCount = Math.max(0, this.activatedCount - 1);
          this.selectUnit(row, col, false);
          return;
        }

        this.renderSidebar();
        return;
      }

      if (clickedUnit && clickedUnit.player === this.currentPlayer && !clickedUnit.done) {
        this.selectUnit(row, col, false);
      } else {
        this.renderSidebar();
      }
    }

    selectUnit(row, col, fromAI) {
      const unit = this.board.unitAt(row, col);
      if (!unit) {
        return false;
      }
      if (unit.player !== this.currentPlayer || unit.done) {
        return false;
      }
      if (!this.canUnitAct(unit)) {
        return false;
      }
      if (this.mode === "ai" && this.currentPlayer === 2 && !fromAI) {
        return false;
      }

      if (!unit.activated) {
        unit.activated = true;
        this.activatedCount += 1;
      }

      this.selectedUnit = unit;
      this.rebuildHighlights();
      this.message = "Юнит выбран: " + unit.name + ". Ходов: " + unit.movesLeft + ".";
      this.renderSidebar();
      return true;
    }

    moveActionsFor(unit) {
      if (!unit || unit.movesLeft <= 0) {
        return [];
      }
      const dirs = [
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
      ];
      const moves = [];

      if (unit.type === "archer") {
        dirs.forEach((d) => {
          for (let step = 1; step <= 2; step += 1) {
            if (step > unit.movesLeft) {
              break;
            }
            const nr = unit.row + d[0] * step;
            const nc = unit.col + d[1] * step;
            if (!this.board.isFree(nr, nc)) {
              break;
            }
            moves.push({ row: nr, col: nc, cost: step });
          }
        });
      } else {
        dirs.forEach((d) => {
          const nr = unit.row + d[0];
          const nc = unit.col + d[1];
          if (this.board.isFree(nr, nc) && unit.movesLeft >= 1) {
            moves.push({ row: nr, col: nc, cost: 1 });
          }
        });
      }

      return moves;
    }

    attackActionsFor(unit) {
      if (!unit || unit.movesLeft <= 0) {
        return [];
      }
      const dirs = [
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
      ];
      const attacks = [];

      if (unit.type === "archer") {
        if (unit.movesLeft < 1) {
          return attacks;
        }
        dirs.forEach((d) => {
          const nr = unit.row + d[0];
          const nc = unit.col + d[1];
          const target = this.board.unitAt(nr, nc);
          if (target && target.player !== unit.player) {
            attacks.push({
              row: nr,
              col: nc,
              cost: 1,
              targetRow: nr,
              targetCol: nc,
              landingRow: unit.row,
              landingCol: unit.col,
              mode: "shot"
            });
          }
        });
        return attacks;
      }

      if (unit.movesLeft < 2) {
        return attacks;
      }

      dirs.forEach((d) => {
        const er = unit.row + d[0];
        const ec = unit.col + d[1];
        const enemy = this.board.unitAt(er, ec);
        if (!enemy || enemy.player === unit.player) {
          return;
        }
        const lr = er + d[0];
        const lc = ec + d[1];
        if (!this.board.isFree(lr, lc)) {
          return;
        }
        attacks.push({
          row: lr,
          col: lc,
          cost: 2,
          targetRow: er,
          targetCol: ec,
          landingRow: lr,
          landingCol: lc,
          mode: "jump"
        });
      });

      return attacks;
    }

    rebuildHighlights() {
      this.clearHighlights();
      if (!this.selectedUnit) {
        return;
      }
      const moves = this.moveActionsFor(this.selectedUnit);
      const attacks = this.attackActionsFor(this.selectedUnit);

      moves.forEach((m) => {
        this.moveMap.set(toKey(m.row, m.col), m);
      });
      attacks.forEach((a) => {
        this.attackMap.set(toKey(a.row, a.col), a);
      });
    }

    clearHighlights() {
      this.moveMap.clear();
      this.attackMap.clear();
    }

    performMove(row, col, fromAI) {
      if (!this.selectedUnit) {
        return false;
      }
      if (this.mode === "ai" && this.currentPlayer === 2 && !fromAI) {
        return false;
      }
      const action = this.moveMap.get(toKey(row, col));
      if (!action) {
        return false;
      }
      if (this.selectedUnit.movesLeft < action.cost) {
        return false;
      }

      this.selectedUnit.row = action.row;
      this.selectedUnit.col = action.col;
      this.selectedUnit.movesLeft -= action.cost;

      if (this.selectedUnit.movesLeft <= 0) {
        this.lastEvent = this.selectedUnit.name + " завершил ход.";
        this.finishSelectedUnit();
      } else {
        this.rebuildHighlights();
        this.message = "Ходов осталось: " + this.selectedUnit.movesLeft + ".";
        this.renderSidebar();
      }
      return true;
    }

    computeDamage(attacker, target) {
      let damage = Math.max(0, attacker.damage - target.armor);
      if (this.shieldTurns[target.player] > 0) {
        damage = Math.max(0, damage - 2);
      }
      return damage;
    }

    performAttack(row, col, fromAI) {
      if (!this.selectedUnit) {
        return false;
      }
      if (this.mode === "ai" && this.currentPlayer === 2 && !fromAI) {
        return false;
      }
      const action = this.attackMap.get(toKey(row, col));
      if (!action) {
        return false;
      }
      if (this.selectedUnit.movesLeft < action.cost) {
        return false;
      }

      const target = this.board.unitAt(action.targetRow, action.targetCol);
      if (!target || target.player === this.selectedUnit.player) {
        return false;
      }

      if (action.mode === "jump") {
        this.selectedUnit.row = action.landingRow;
        this.selectedUnit.col = action.landingCol;
      }

      const damage = this.computeDamage(this.selectedUnit, target);
      target.hp -= damage;
      this.selectedUnit.movesLeft -= action.cost;

      this.lastEvent =
        this.selectedUnit.name +
        " атакует " +
        target.name +
        " на " +
        damage +
        " урона.";

      if (target.hp <= 0) {
        this.lastEvent += " " + target.name + " повержен.";
      }

      this.board.removeDead();
      if (this.previewUnitId !== null && !this.board.units.some((u) => u.id === this.previewUnitId)) {
        this.previewUnitId = null;
      }

      this.checkWinner();
      if (this.winner !== null) {
        this.selectedUnit = null;
        this.clearHighlights();
        this.renderSidebar();
        return true;
      }

      if (this.selectedUnit.movesLeft <= 0) {
        this.finishSelectedUnit();
      } else {
        this.rebuildHighlights();
        this.message = "Ходов осталось: " + this.selectedUnit.movesLeft + ".";
        this.renderSidebar();
      }
      return true;
    }

    finishSelectedUnit() {
      if (!this.selectedUnit) {
        return;
      }
      this.selectedUnit.done = true;
      this.selectedUnit.movesLeft = 0;
      this.selectedUnit = null;
      this.clearHighlights();

      if (this.winner !== null) {
        this.renderSidebar();
        return;
      }

      if (this.shouldEndTurn()) {
        this.endTurn();
      } else {
        const left = Math.max(0, this.maxActivatedPerTurn - this.activatedCount);
        this.message = "Выберите юнит. Осталось активаций: " + left + ".";
        this.renderSidebar();
      }
    }

    shouldEndTurn() {
      const own = this.ownUnits(this.currentPlayer);
      if (!own.length) {
        return true;
      }
      if (own.every((u) => u.done)) {
        return true;
      }
      if (this.activatedCount >= Math.min(this.maxActivatedPerTurn, own.length) && this.selectedUnit === null) {
        return true;
      }
      return false;
    }

    endTurn() {
      if (this.winner !== null) {
        return;
      }

      const defender = otherPlayer(this.currentPlayer);
      if (this.shieldTurns[defender] > 0) {
        this.shieldTurns[defender] -= 1;
      }

      this.currentPlayer = defender;
      this.turnNumber += 1;
      this.startTurn();
    }

    forceEndTurn() {
      this.selectedUnit = null;
      this.clearHighlights();
      this.endTurn();
    }

    skipSelected(fromAI) {
      if (!this.selectedUnit) {
        return;
      }
      if (this.mode === "ai" && this.currentPlayer === 2 && !fromAI) {
        return;
      }
      this.lastEvent = this.selectedUnit.name + " пропускает ход.";
      this.finishSelectedUnit();
    }

    canAfford(inv, recipe) {
      const names = Object.keys(recipe);
      for (let i = 0; i < names.length; i += 1) {
        const name = names[i];
        if ((inv[name] || 0) < recipe[name]) {
          return false;
        }
      }
      return true;
    }

    spend(inv, recipe) {
      Object.keys(recipe).forEach((name) => {
        inv[name] -= recipe[name];
      });
    }

    drawArtifact(fromAI) {
      if (!this.selectedUnit) {
        return false;
      }
      if (this.mode === "ai" && this.currentPlayer === 2 && !fromAI) {
        return false;
      }
      if (this.selectedUnit.movesLeft < 1) {
        return false;
      }
      if (!this.board.inRuins(this.selectedUnit.row, this.selectedUnit.col)) {
        this.message = "Юнит должен стоять в руинах.";
        this.renderSidebar();
        return false;
      }
      const artifact = randomChoice(ARTIFACTS);
      this.inventory[this.currentPlayer][artifact] += 1;
      this.selectedUnit.movesLeft -= 1;
      this.lastEvent = "Найден артефакт: " + artifact + ".";

      if (this.selectedUnit.movesLeft <= 0) {
        this.finishSelectedUnit();
      } else {
        this.rebuildHighlights();
        this.renderSidebar();
      }
      return true;
    }

    castSpell(index, fromAI) {
      if (!this.selectedUnit) {
        return false;
      }
      if (this.mode === "ai" && this.currentPlayer === 2 && !fromAI) {
        return false;
      }
      if (this.selectedUnit.movesLeft < 1) {
        return false;
      }
      if (!this.board.isTower(this.selectedUnit.row, this.selectedUnit.col)) {
        this.message = "Заклинания доступны только на башне мага.";
        this.renderSidebar();
        return false;
      }

      const spell = SPELLS[index];
      if (!spell) {
        return false;
      }

      const inv = this.inventory[this.currentPlayer];
      if (!this.canAfford(inv, spell.recipe)) {
        this.message = "Недостаточно артефактов для заклинания.";
        this.renderSidebar();
        return false;
      }

      this.spend(inv, spell.recipe);
      const allies = this.ownUnits(this.currentPlayer);

      if (index === 0) {
        allies.forEach((u) => {
          u.maxHp += 2;
          u.hp += 2;
        });
      } else if (index === 1) {
        allies.forEach((u) => {
          u.maxArmor += 2;
          u.armor += 2;
        });
      } else if (index === 2) {
        this.shieldTurns[this.currentPlayer] = 1;
      }

      this.selectedUnit.movesLeft -= 1;
      this.lastEvent = "Заклинание: " + spell.name + ".";

      if (this.selectedUnit.movesLeft <= 0) {
        this.finishSelectedUnit();
      } else {
        this.rebuildHighlights();
        this.renderSidebar();
      }
      return true;
    }

    craftWeapon(index) {
      if (!this.selectedUnit || this.winner !== null) {
        return false;
      }
      if (this.mode === "ai" && this.currentPlayer === 2) {
        return false;
      }

      const recipe = WEAPONS[index];
      if (!recipe) {
        return false;
      }
      if (recipe.archerOnly && this.selectedUnit.type !== "archer") {
        this.message = "Синий лук можно крафтить только лучнику.";
        this.renderSidebar();
        return false;
      }

      const inv = this.inventory[this.currentPlayer];
      if (!this.canAfford(inv, recipe.recipe)) {
        this.message = "Недостаточно артефактов для крафта.";
        this.renderSidebar();
        return false;
      }

      this.spend(inv, recipe.recipe);
      this.selectedUnit.damage += recipe.amount;
      this.lastEvent = "Скрафчено: " + recipe.name + ".";
      this.renderSidebar();
      return true;
    }

    surrender() {
      if (this.screen !== "game" || this.winner !== null) {
        return;
      }
      if (this.mode === "ai" && this.currentPlayer === 2) {
        return;
      }
      this.winner = otherPlayer(this.currentPlayer);
      this.message = "Игрок " + this.currentPlayer + " сдался.";
      this.lastEvent = "Победа игрока " + this.winner + ".";
      this.selectedUnit = null;
      this.clearHighlights();
      this.renderSidebar();
    }

    checkWinner() {
      const p1 = this.ownUnits(1).length;
      const p2 = this.ownUnits(2).length;
      if (p1 <= 0) {
        this.winner = 2;
        this.message = "Победа игрока 2!";
      } else if (p2 <= 0) {
        this.winner = 1;
        this.message = "Победа игрока 1!";
      }
    }

    renderSidebar() {
      if (this.screen === "loading") {
        const st = this.assets.stats();
        this.sidebar.innerHTML =
          '<div class="menu-wrap">' +
          '<div class="menu-title">Рыцари и Замки</div>' +
          '<div class="card loading">Загрузка спрайтов: ' + st.resolved + '/' + st.pending + '</div>' +
          '<div class="card rules">Игра запускается после загрузки ассетов или через 5 секунд таймаута.</div>' +
          '</div>';
        return;
      }

      if (this.screen === "menu") {
        this.sidebar.innerHTML =
          '<div class="menu-wrap">' +
          '<div class="menu-title">Рыцари и Замки</div>' +
          '<div class="card">' +
          '<div class="line">Тактическая браузерная игра на поле 10x20.</div>' +
          '</div>' +
          '<div class="card">' +
          '<h3>Правила</h3>' +
          '<div class="rules">Правила скоро будут добавлены...</div>' +
          '</div>' +
          '<div class="menu-buttons">' +
          '<button class="btn secondary" data-action="start-pvp">2 Игрока</button>' +
          '<button class="btn primary" data-action="start-ai">Против ИИ</button>' +
          '</div>' +
          '</div>';
        return;
      }

      const p1Count = this.ownUnits(1).length;
      const p2Count = this.ownUnits(2).length;
      const playerClass = this.currentPlayer === 1 ? "player-p1" : "player-p2";
      const inv = this.inventory[this.currentPlayer];
      const activationLeft = Math.max(0, this.maxActivatedPerTurn - this.activatedCount);

      let html = "";
      html += '<div class="player-label ' + playerClass + '">Игрок ' + this.currentPlayer + '</div>';
      html += '<div class="message">' + this.escape(this.message) + '</div>';
      html += '<div class="score">Счёт: P1 ' + p1Count + ' : ' + p2Count + ' P2</div>';
      html += '<div class="line">Режим: ' + (this.mode === "ai" ? "Против ИИ" : "2 Игрока") + '</div>';
      html += '<div class="line">Активаций осталось: ' + activationLeft + '</div>';
      html += '<button class="btn secondary" data-action="back-menu" style="margin-top:8px">В меню</button>';

      if (this.shieldTurns[1] > 0) {
        html += '<div class="badge p1">Щит P1 активен</div>';
      }
      if (this.shieldTurns[2] > 0) {
        html += '<div class="badge p2">Щит P2 активен</div>';
      }

      if (this.lastEvent) {
        html += '<div class="card"><div class="hint">' + this.escape(this.lastEvent) + '</div></div>';
      }

      html += '<hr class="sep" />';
      html += '<div class="section"><h3>Инвентарь артефактов (Игрок ' + this.currentPlayer + ')</h3>';
      ARTIFACTS.forEach((name) => {
        const count = inv[name] || 0;
        const state = count > 0 ? "has" : "empty";
        const color = count > 0 ? ARTIFACT_COLORS[name] : "#8f7d65";
        html +=
          '<div class="inventory-row ' +
          state +
          '" style="color:' +
          color +
          '">' +
          this.escape(name) +
          ': ' +
          count +
          '</div>';
      });
      html += "</div>";

      const previewUnit = this.getPreviewUnit();
      if (previewUnit) {
        html += '<hr class="sep" />';
        html += '<div class="section preview">';
        html += '<h3>Превью юнита</h3>';
        html += '<canvas id="previewSprite" width="144" height="144"></canvas>';
        html +=
          '<div class="preview-title">' +
          this.escape(previewUnit.name) +
          ' <span class="tag" style="color:' +
          (previewUnit.player === 1 ? COLORS.p1 : COLORS.p2) +
          '">Игрок ' +
          previewUnit.player +
          "</span></div>";
        html +=
          '<div class="kv">HP: ' +
          previewUnit.hp +
          '/' +
          previewUnit.maxHp +
          ' | Armor: ' +
          previewUnit.armor +
          ' | Damage: ' +
          previewUnit.damage +
          ' | Moves: ' +
          previewUnit.movesLeft +
          '/' +
          previewUnit.maxMoves +
          "</div>";
        html += '<button class="btn" data-action="clear-preview">Закрыть превью</button>';
        html += "</div>";
      }

      if (this.selectedUnit && this.selectedUnit.player === this.currentPlayer && this.winner === null) {
        const u = this.selectedUnit;
        html += '<hr class="sep" />';
        html += '<div class="section">';
        html += '<h3>Выбранный юнит</h3>';
        html +=
          '<div class="line">' +
          this.escape(u.name) +
          ' | HP ' +
          u.hp +
          '/' +
          u.maxHp +
          ' | Armor ' +
          u.armor +
          ' | DMG ' +
          u.damage +
          ' | Ходы ' +
          u.movesLeft +
          '/' +
          u.maxMoves +
          "</div>";

        if (this.board.inRuins(u.row, u.col) && u.movesLeft > 0) {
          html += '<button class="btn secondary" data-action="draw-artifact">Тянуть артефакт</button>';
        }

        if (this.board.isTower(u.row, u.col) && u.movesLeft > 0) {
          html += '<h3>Заклинания</h3>';
          SPELLS.forEach((spell, idx) => {
            const can = this.canAfford(this.inventory[this.currentPlayer], spell.recipe);
            html +=
              '<button class="btn" data-action="cast-spell" data-idx="' +
              idx +
              '" ' +
              (can ? "" : "disabled") +
              '>' +
              this.escape(spell.name) +
              '<div class="recipe">' +
              this.escape(cloneRecipeText(spell.recipe)) +
              "</div></button>";
          });
        }

        html += '<h3>Крафт оружия</h3>';
        WEAPONS.forEach((w, idx) => {
          const canRecipe = this.canAfford(this.inventory[this.currentPlayer], w.recipe);
          const unitOk = !w.archerOnly || u.type === "archer";
          const can = canRecipe && unitOk;
          html +=
            '<button class="btn" data-action="craft" data-idx="' +
            idx +
            '" ' +
            (can ? "" : "disabled") +
            '>' +
            this.escape(w.name) +
            '<div class="recipe">' +
            this.escape(cloneRecipeText(w.recipe)) +
            "</div></button>";
        });

        html += "</div>";
      }

      html += '<hr class="sep" />';
      html +=
        '<button class="btn skip" data-action="skip" ' +
        (this.selectedUnit && this.winner === null ? "" : "disabled") +
        '>Пропустить (ПКМ/Space)</button>';
      html +=
        '<button class="btn danger" data-action="surrender" ' +
        (this.winner === null ? "" : "disabled") +
        '>Сдаться</button>';

      if (this.winner !== null) {
        html += '<hr class="sep" />';
        html +=
          '<div class="card"><h3>Победа</h3><div class="line" style="color:' +
          (this.winner === 1 ? COLORS.p1 : COLORS.p2) +
          '">Победил игрок ' +
          this.winner +
          "</div></div>";
        html += '<button class="btn restart" data-action="restart">Рестарт</button>';
      }

      this.sidebar.innerHTML = html;
      this.paintPreviewSprite();
    }

    paintPreviewSprite() {
      const unit = this.getPreviewUnit();
      if (!unit) {
        return;
      }
      const canvas = document.getElementById("previewSprite");
      if (!canvas) {
        return;
      }
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#241c15";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (unit.type === "cavalry") {
        this.drawMountedComposite(ctx, unit, 0, 0, canvas.width, canvas.height);
        return;
      }

      const key = this.spriteKeyForUnit(unit);
      const img = this.assets.get(key);
      if (img) {
        const frame = UNIT_TYPES[unit.type].frame;
        const frameIndex = this.frameIndexForUnit(unit);
        ctx.drawImage(img, frame * frameIndex, 0, frame, frame, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = unit.player === 1 ? COLORS.p1 : COLORS.p2;
        ctx.fillRect(22, 22, 100, 100);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 44px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(UNIT_TYPES[unit.type].letter, 72, 72);
      }
    }

    getPreviewUnit() {
      if (this.previewUnitId === null) {
        return null;
      }
      const unit = this.board.units.find((u) => u.id === this.previewUnitId && u.alive());
      if (!unit) {
        this.previewUnitId = null;
        return null;
      }
      return unit;
    }

    escape(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    spriteKeyForUnit(unit) {
      const color = unit.player === 1 ? "blue" : "red";
      return "u_" + color + "_" + unit.type;
    }

    drawMountedComposite(ctx, unit, dx, dy, dw, dh) {
      const horse = this.assets.get("horse_knight_base");
      if (horse) {
        // Use tight crop of a gallop frame so the horse is readable and fits the tile.
        const sx = 149;
        const sy = 165;
        const sw = 91;
        const sh = 57;
        const hx = dx + dw * 0.02;
        const hy = dy + dh * 0.46;
        const hw = dw * 0.96;
        const hh = dh * 0.46;
        ctx.drawImage(horse, sx, sy, sw, sh, hx, hy, hw, hh);
      } else {
        ctx.fillStyle = "rgba(110, 102, 96, 0.9)";
        ctx.beginPath();
        ctx.ellipse(dx + dw * 0.54, dy + dh * 0.63, dw * 0.34, dh * 0.2, -0.15, 0, Math.PI * 2);
        ctx.fill();
      }

      const rider = this.assets.get(this.spriteKeyForUnit(unit));
      if (rider) {
        // Lancer crop tuned to keep spear + torso visible while still fitting in one tile.
        const rsx = 115;
        const rsy = 48;
        const rsw = 69;
        const rsh = 150;
        const riderW = dw * 0.34;
        const riderH = dh * 0.50;
        const rx = dx + dw * 0.33;
        // Seat rider lower so he visually sits on the horse instead of floating.
        const ry = dy + dh * 0.11;
        ctx.drawImage(rider, rsx, rsy, rsw, rsh, rx, ry, riderW, riderH);
      } else {
        ctx.fillStyle = unit.player === 1 ? COLORS.p1 : COLORS.p2;
        ctx.fillRect(dx + dw * 0.28, dy + dh * 0.1, dw * 0.35, dh * 0.35);
      }
    }

    frameIndexForUnit(unit) {
      return 0;
    }

    drawMenuCanvas() {
      const ctx = this.ctx;
      ctx.fillStyle = "#0e0e0e";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      const cover = this.assets.get("cover");
      if (cover) {
        const scale = Math.min(WIDTH / cover.width, HEIGHT / cover.height);
        const dw = cover.width * scale;
        const dh = cover.height * scale;
        const dx = (WIDTH - dw) / 2;
        const dy = (HEIGHT - dh) / 2;
        ctx.drawImage(cover, dx, dy, dw, dh);
      } else {
        ctx.fillStyle = "#3a2a1b";
        ctx.fillRect(28, 180, WIDTH - 56, HEIGHT - 360);
        ctx.fillStyle = "#f0d7a6";
        ctx.font = "bold 42px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Рыцари и Замки", WIDTH / 2, HEIGHT / 2 - 12);
      }

      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, WIDTH - 1, HEIGHT - 1);
    }

    drawGameCanvas() {
      const ctx = this.ctx;

      for (let row = 0; row < ROWS; row += 1) {
        for (let col = 0; col < COLS; col += 1) {
          ctx.fillStyle = (row + col) % 2 === 0 ? COLORS.groundA : COLORS.groundB;
          ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }

      this.drawCastle(1, 0, 3);
      this.drawCastle(2, 16, 3);
      this.drawTowers();
      this.drawRuins();

      if (this.selectedUnit) {
        const sx = this.selectedUnit.col * CELL_SIZE;
        const sy = this.selectedUnit.row * CELL_SIZE;
        ctx.strokeStyle = COLORS.selected;
        ctx.lineWidth = 3;
        ctx.strokeRect(sx + 2, sy + 2, CELL_SIZE - 4, CELL_SIZE - 4);
      }

      this.moveMap.forEach((m) => {
        ctx.fillStyle = COLORS.move;
        ctx.fillRect(m.col * CELL_SIZE, m.row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      });

      this.attackMap.forEach((a) => {
        ctx.fillStyle = COLORS.attack;
        ctx.fillRect(a.col * CELL_SIZE, a.row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      });

      this.board.units.forEach((u) => {
        this.drawUnit(u);
      });

      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 1;
      for (let row = 0; row <= ROWS; row += 1) {
        ctx.beginPath();
        ctx.moveTo(0, row * CELL_SIZE + 0.5);
        ctx.lineTo(WIDTH, row * CELL_SIZE + 0.5);
        ctx.stroke();
      }
      for (let col = 0; col <= COLS; col += 1) {
        ctx.beginPath();
        ctx.moveTo(col * CELL_SIZE + 0.5, 0);
        ctx.lineTo(col * CELL_SIZE + 0.5, HEIGHT);
        ctx.stroke();
      }
    }

    drawCastle(player, topRow, leftCol) {
      const ctx = this.ctx;
      const x = leftCol * CELL_SIZE;
      const y = topRow * CELL_SIZE;
      const size = CELL_SIZE * 4;
      const key = player === 1 ? "castle_blue" : "castle_red";
      const img = this.assets.get(key);

      if (img) {
        ctx.drawImage(img, x, y, size, size);
      } else {
        ctx.fillStyle = player === 1 ? "rgba(70,130,220,0.30)" : "rgba(220,70,70,0.30)";
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = player === 1 ? COLORS.p1 : COLORS.p2;
        ctx.lineWidth = 3;
        ctx.strokeRect(x + 2, y + 2, size - 4, size - 4);
        ctx.fillStyle = player === 1 ? COLORS.p1 : COLORS.p2;
        ctx.font = "bold 20px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("CASTLE", x + size / 2, y + size / 2);
      }
    }

    drawTowers() {
      const ctx = this.ctx;
      const img = this.assets.get("tower_blue");
      TOWERS.forEach((t) => {
        const x = t.col * CELL_SIZE;
        const y = t.row * CELL_SIZE;
        if (img) {
          ctx.drawImage(img, x, y, CELL_SIZE, CELL_SIZE);
        } else {
          ctx.fillStyle = "#513c6f";
          ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
          ctx.strokeStyle = "#b89dff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2);
          ctx.fillStyle = "#decfff";
          ctx.font = "bold 14px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("T", x + CELL_SIZE / 2, y + CELL_SIZE / 2);
        }
      });
    }

    drawRuins() {
      const ctx = this.ctx;
      const x = RUINS.left * CELL_SIZE;
      const y = RUINS.top * CELL_SIZE;
      const w = RUINS.width * CELL_SIZE;
      const h = RUINS.height * CELL_SIZE;

      ctx.fillStyle = "#463c2d";
      ctx.fillRect(x, y, w, h);

      const monastery = this.assets.get("monastery_ruins");
      if (monastery) {
        ctx.save();
        ctx.globalAlpha = 0.85;
        // Lower body of monastery sprite keeps Tiny Swords style and fits 2x2 ruins zone.
        ctx.drawImage(monastery, 0, 128, 192, 192, x + 3, y - 6, w - 6, h + 12);
        ctx.restore();
      }

      this.drawBrokenColumn(x + 12, y + 20, 15, 40, "#8a8178");
      this.drawBrokenColumn(x + 60, y + 24, 14, 35, "#776d63");

      ctx.fillStyle = "rgba(39,30,23,0.9)";
      ctx.beginPath();
      ctx.moveTo(x + 4, y + 2);
      ctx.lineTo(x + 26, y + 2);
      ctx.lineTo(x + 17, y + 18);
      ctx.lineTo(x + 4, y + 15);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x + w - 3, y + 8);
      ctx.lineTo(x + w - 24, y + 14);
      ctx.lineTo(x + w - 10, y + 28);
      ctx.lineTo(x + w - 3, y + 25);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(30,24,19,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + 30, y + 24);
      ctx.lineTo(x + 38, y + 40);
      ctx.lineTo(x + 30, y + 56);
      ctx.lineTo(x + 42, y + 74);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x + 70, y + 18);
      ctx.lineTo(x + 58, y + 36);
      ctx.lineTo(x + 66, y + 52);
      ctx.lineTo(x + 54, y + 72);
      ctx.stroke();

      ctx.fillStyle = "#68615a";
      ctx.beginPath();
      ctx.ellipse(x + 22, y + 76, 10, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#76706a";
      ctx.beginPath();
      ctx.ellipse(x + 48, y + 67, 13, 6, 0.28, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#5f8053";
      ctx.beginPath();
      ctx.ellipse(x + 34, y + 84, 8, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 68, y + 83, 7, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,0.26)";
      ctx.fillRect(x, y + 10, w, h - 10);
      ctx.fillStyle = "#d4c4a7";
      ctx.font = "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Руины", x + w / 2, y + h - 10);
    }

    drawBrokenColumn(x, y, w, h, color) {
      const ctx = this.ctx;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, y + h);
      ctx.lineTo(x + w, y + h);
      ctx.lineTo(x + w, y + 14);
      ctx.lineTo(x + w - 5, y + 8);
      ctx.lineTo(x + w - 10, y + 12);
      ctx.lineTo(x + w - 13, y + 7);
      ctx.lineTo(x + 5, y + 10);
      ctx.lineTo(x + 2, y + 6);
      ctx.lineTo(x, y + 14);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.fillRect(x + 2, y + 16, w - 4, h - 18);
    }

    drawUnit(unit) {
      const ctx = this.ctx;
      const baseX = unit.col * CELL_SIZE;
      const baseY = unit.row * CELL_SIZE;

      if (unit.type === "cavalry") {
        // Mounted units are rendered as horse+rider composite and stay inside one tile.
        this.drawMountedComposite(ctx, unit, baseX, baseY, CELL_SIZE, CELL_SIZE);
      } else {
        const sprite = this.assets.get(this.spriteKeyForUnit(unit));
        const frame = UNIT_TYPES[unit.type].frame;
        const frameIndex = this.frameIndexForUnit(unit);

        if (sprite) {
          ctx.drawImage(
            sprite,
            frame * frameIndex,
            0,
            frame,
            frame,
            baseX,
            baseY,
            CELL_SIZE,
            CELL_SIZE
          );
        } else {
          ctx.fillStyle = unit.player === 1 ? COLORS.p1 : COLORS.p2;
          ctx.fillRect(baseX + 5, baseY + 5, CELL_SIZE - 10, CELL_SIZE - 10);
          ctx.fillStyle = "#fff";
          ctx.font = "bold 17px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(UNIT_TYPES[unit.type].letter, baseX + CELL_SIZE / 2, baseY + CELL_SIZE / 2);
        }
      }

      if (unit.id === this.previewUnitId) {
        ctx.strokeStyle = "rgba(255,255,255,0.75)";
        ctx.lineWidth = 2;
        ctx.strokeRect(baseX + 3, baseY + 3, CELL_SIZE - 6, CELL_SIZE - 6);
      }

      const barWidth = CELL_SIZE - 6;
      const hpY = baseY + CELL_SIZE - 8;
      const armorY = hpY - 5;

      ctx.fillStyle = "#141414";
      ctx.fillRect(baseX + 3, armorY, barWidth, 4);
      ctx.fillRect(baseX + 3, hpY, barWidth, 4);

      const hpRatio = unit.maxHp > 0 ? Math.max(0, unit.hp) / unit.maxHp : 0;
      const armorRatio = unit.maxArmor > 0 ? Math.max(0, unit.armor) / unit.maxArmor : 0;

      ctx.fillStyle = "#2ed14e";
      ctx.fillRect(baseX + 3, hpY, barWidth * hpRatio, 4);
      ctx.fillStyle = "#4f91ff";
      ctx.fillRect(baseX + 3, armorY, barWidth * armorRatio, 4);

      if (unit.done && unit.player === this.currentPlayer) {
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(baseX, baseY, CELL_SIZE, CELL_SIZE);
      }

      if (this.selectedUnit && this.selectedUnit.id === unit.id) {
        ctx.strokeStyle = COLORS.selected;
        ctx.lineWidth = 2;
        ctx.strokeRect(baseX + 1, baseY + 1, CELL_SIZE - 2, CELL_SIZE - 2);
      }
    }

    drawLoadingCanvas() {
      const ctx = this.ctx;
      ctx.fillStyle = "#0e0e0e";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#f0d28d";
      ctx.font = "bold 28px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Загрузка...", WIDTH / 2, HEIGHT / 2 - 20);

      const st = this.assets.stats();
      ctx.font = "16px sans-serif";
      ctx.fillStyle = "#c9b48a";
      ctx.fillText(st.resolved + " / " + st.pending, WIDTH / 2, HEIGHT / 2 + 16);

      ctx.strokeStyle = COLORS.grid;
      ctx.strokeRect(0.5, 0.5, WIDTH - 1, HEIGHT - 1);
    }

    draw() {
      if (this.screen === "loading") {
        this.drawLoadingCanvas();
        return;
      }
      if (this.screen === "menu") {
        this.drawMenuCanvas();
        return;
      }
      this.drawGameCanvas();
    }

    loop() {
      this.draw();
      this.ai.update();
      requestAnimationFrame(() => this.loop());
    }
  }

  const assets = new AssetStore();
  const root = "Tiny Swords/Tiny Swords (Free Pack)/";

  assets.add("cover", "Knights_and_Castles_1920x1080.png");

  assets.add("u_blue_knight", root + "Units/Blue Units/Warrior/Warrior_Idle.png");
  assets.add("u_blue_cavalry", root + "Units/Blue Units/Lancer/Lancer_Idle.png");
  assets.add("u_blue_archer", root + "Units/Blue Units/Archer/Archer_Idle.png");

  assets.add("u_red_knight", root + "Units/Red Units/Warrior/Warrior_Idle.png");
  assets.add("u_red_cavalry", root + "Units/Red Units/Lancer/Lancer_Idle.png");
  assets.add("u_red_archer", root + "Units/Red Units/Archer/Archer_Idle.png");

  assets.add("castle_blue", root + "Buildings/Blue Buildings/Castle.png");
  assets.add("castle_red", root + "Buildings/Red Buildings/Castle.png");
  assets.add("tower_blue", root + "Buildings/Blue Buildings/Tower.png");
  assets.add("monastery_ruins", root + "Buildings/Blue Buildings/Monastery.png");
  assets.add("horse_knight_base", "assets/external/horse_sheet.png");

  const canvas = document.getElementById("gameCanvas");
  const sidebar = document.getElementById("sidebar");
  const game = new KnightsAndCastlesGame(canvas, sidebar, assets);

  assets.loadAll();

  let launched = false;
  const boot = () => {
    if (launched) {
      return;
    }
    launched = true;
    game.onAssetsReady();
  };

  assets.whenFinished(boot);
  setTimeout(boot, 5000);
})();
</script>
</body>
</html>
